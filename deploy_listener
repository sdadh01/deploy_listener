#!/usr/bin/env ruby
# encoding: utf-8

VERSION = "1.0.0"

PORT = 2000
URLPREFIX = "/deploy_release"

################################################
# Option parsing
require 'optparse'

options = { :releasefile => '.release', 
  :logfile => '/dev/null', 
  :port => PORT, 
  :configfile => "false",
  :urlprefix => URLPREFIX
}

daemonize_help = "run daemonized in the background (default: false)"
pidfile_help   = "the pid filename"
logfile_help   = "the log filename (default: #{options[:logfile]})"
port_help      = "port to listen on (default: #{PORT})"
releasefile_help = "filename for file containing release to deploy (default: #{options[:releasefile]})"
configfile_help = "filename for yaml containing config - config file overrides command line options"

include_help   = "an additional $LOAD_PATH (may be used more than once)"
debug_help     = "set $DEBUG to true"
warn_help      = "enable warnings"

op = OptionParser.new
op.banner =  "deploy_listener: Write deploy release value to file from HTTP request"
op.separator ""
op.separator "Usage: deploy_listener [options]"
op.separator ""

op.separator "Process options:"
op.on("-d", "--daemonize",   daemonize_help) {         options[:daemonize] = true  }
op.on("-p", "--pid PIDFILE", pidfile_help)   { |value| options[:pidfile]   = value }
op.on("-P", "--port PORT", port_help)   { |value| options[:port]   = value }
op.on("-l", "--log LOGFILE", logfile_help)   { |value| options[:logfile]   = value }
op.on("-r", "--release_file RELEASE_FILE", releasefile_help)   { |value| options[:releasefile]   = value }
op.on("-c", "--config CONFIGFILE", configfile_help) { |value| options[:configfile]   = value }

op.separator ""
op.separator "Ruby options:"
op.on("-I", "--include PATH", include_help) { |value| $LOAD_PATH.unshift(*value.split(":").map{|v| File.expand_path(v)}) }
op.on(      "--debug",        debug_help)   { $DEBUG = true }
op.on(      "--warn",         warn_help)    { $-w = true    }

op.separator ""
op.separator "Common options:"
op.on("-h", "--help")    { options[:action] = :help    }
op.on("-v", "--version") { options[:action] = :version }

op.separator ""
op.parse!(ARGV)

###################################################
# Option override by config file if it is specified
if File.exists?(options[:configfile])
  require 'yaml'
  options = YAML.load_file(options[:configfile])
  options = options.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
end

################################################
# log file, release file and pid file handling
def logfile
  options[:logfile]
end

def releasefile
  options[:releasefile]
end

def logfile?
  !logfile.nil?
end

def releasefile?
  !releasefile.nil?
end

def write_pid(pidfile)
  begin
    File.open(pidfile, ::File::CREAT | ::File::EXCL | ::File::WRONLY){|f| f.write("#{Process.pid}") }
    at_exit { File.delete(pidfile) if File.exists?(pidfile) }
  rescue Errno::EEXIST
    check_pid
    retry
  end
end

def check_pid(pidfile)
  case pid_status(pidfile)
  when :running, :not_owned
    puts "A server is already running. Check #{pidfile}"
    exit(1)
  when :dead
    File.delete(pidfile)
  end
end

def pid_status(pidfile)
  return :exited unless File.exists?(pidfile)
  pid = ::File.read(pidfile).to_i
  return :dead if pid == 0
  Process.kill(0, pid)
  :running
rescue Errno::ESRCH
  :dead
rescue Errno::EPERM
  :not_owned
end

def write_release(releasefile, revision)
  File.delete(releasefile) if File.exists?(releasefile)
  File.open(releasefile, ::File::CREAT | ::File::EXCL | ::File::WRONLY){|f| f.write("#{revision}") }
  return :exited
end

################################################
# Main
case options[:action]
when :help    then puts op.to_s
when :version then puts VERSION
else
  options[:logfile] = File.expand_path(options[:logfile]) # daemonization might change CWD so expand any relative paths in advance
  options[:pidfile] = File.expand_path(options[:pidfile]) if options[:pidfile]# (ditto)
  options[:releasefile] = File.expand_path(options[:releasefile])  # (ditto)
  
  check_pid(options[:pidfile]) if options[:pidfile]
  if options[:daemonize]
    puts "deploy_launcher now running as PID=#{Process.pid} on port #{options[:port]}"
    Process.daemon 
  end
  write_pid(options[:pidfile]) if options[:pidfile]
  
  require 'sinatra'

  set :bind, '0.0.0.0'
  set :port, options[:port]
  
  configure do
    file = File.new(options[:logfile], 'a+')
    file.sync = true
    use Rack::CommonLogger, file
  end
  
  # basic token based authentication - could be improved
  if options[:use_auth]
    before do
      if env['HTTP_AUTH_KEY'] != options[:auth_key]
        error 401
      end
    end
  end
     
  get "#{options[:urlprefix]}/:revision" do
    revision = params['revision']
    write_release(options[:releasefile],revision)
    "Updating revision to #{revision}\n"
  end
  
  not_found do
    "404 Not Found\n"
  end
end